import { supabase } from '@/integrations/supabase/client';
import { SolanaBlockchainService } from './solana/SolanaBlockchainService';
import { mintService } from './mintService';

interface JobLifecycleEvent {
  userId: string;
  machineId: string;
  activityType: string;
  timestamp: string;
  details?: any;
}

interface UptimeSession {
  machineId: string;
  startTime: Date;
  intervalId: NodeJS.Timeout;
}

interface JobSession {
  machineId: string;
  startTime: Date;
  lastActivity: Date;
  jobData: any;
}

/**
 * MINT token reward service - direct job completion rewards
 */
export class MintRewardService {
  private uptimeSessions = new Map<string, UptimeSession>();
  private activeJobs = new Map<string, JobSession>();
  private blockchainService: SolanaBlockchainService;

  constructor() {
    this.blockchainService = new SolanaBlockchainService();
  }

  /**
   * Record job lifecycle events and award MINT tokens
   */
  async recordJobLifecycleEvent(event: JobLifecycleEvent): Promise<void> {
    console.log('Recording job lifecycle event:', event);

    try {
      // Only job completion earns MINT - simplified
      if (event.activityType === 'job_completion_success') {
        // Simple flat reward: 1 MINT per job
        const mintReward = mintService.calculateMintReward(event.activityType);
        
        if (mintReward > 0) {
          await this.awardMintToUser(event.userId, mintReward, event.activityType);
        }
      }

    } catch (error) {
      console.error('Error processing job lifecycle event:', error);
    }
  }


  /**
   * Start tracking uptime for a machine
   */
  async startUptimeTracking(machineId: string): Promise<void> {
    if (this.uptimeSessions.has(machineId)) {
      console.log('Uptime tracking already active for machine:', machineId);
      return;
    }

    const startTime = new Date();
    
    // Schedule hourly uptime rewards
    const intervalId = setInterval(() => {
      this.scheduleUptimeRewards(machineId);
    }, 60 * 60 * 1000); // Every hour

    this.uptimeSessions.set(machineId, {
      machineId,
      startTime,
      intervalId
    });

    console.log('Started uptime tracking for machine:', machineId);
  }

  /**
   * Stop tracking uptime for a machine
   */
  async stopUptimeTracking(machineId: string): Promise<void> {
    const session = this.uptimeSessions.get(machineId);
    if (!session) {
      console.log('No uptime session found for machine:', machineId);
      return;
    }

    clearInterval(session.intervalId);
    
    // Record final uptime session
    const endTime = new Date();
    const uptimeSeconds = Math.floor((endTime.getTime() - session.startTime.getTime()) / 1000);
    
    await supabase.from('machine_uptime').insert({
      machine_id: machineId,
      session_start: session.startTime.toISOString(),
      session_end: endTime.toISOString(),
      uptime_seconds: uptimeSeconds,
      points_awarded: 0 // No MINT rewards for uptime in new system
    });

    this.uptimeSessions.delete(machineId);
    console.log('Stopped uptime tracking for machine:', machineId);
  }

  /**
   * Schedule hourly uptime rewards
   */
  private async scheduleUptimeRewards(machineId: string): Promise<void> {
    try {
      // Get machine's user
      const { data: machine } = await supabase
        .from('machines')
        .select('user_id')
        .eq('id', machineId)
        .single();

      if (!machine) {
        console.error('Machine not found:', machineId);
        return;
      }

      // No uptime rewards in new MINT system - just tracking
      console.log(`Uptime tracked for machine ${machineId} - no rewards`);

    } catch (error) {
      console.error('Error scheduling uptime rewards:', error);
    }
  }

  /**
   * Process telemetry data and detect job events
   */
  async processTelemetryData(
    machineId: string, 
    telemetryData: any, 
    userId: string
  ): Promise<void> {
    try {
      // Analyze for job lifecycle events
      const events = await this.analyzeJobLifecycleEvents(telemetryData, machineId, userId);
      
      // Process each detected event
      for (const event of events) {
        await this.recordJobLifecycleEvent(event);
        
        // Write important events to blockchain
        if (['job_completion_success', 'job_completion_failure'].includes(event.activityType)) {
          await this.writeJobEventToBlockchain(event);
        }
      }

    } catch (error) {
      console.error('Error processing telemetry data:', error);
    }
  }

  /**
   * Analyze telemetry data for job lifecycle events
   */
  private async analyzeJobLifecycleEvents(
    telemetryData: any, 
    machineId: string, 
    userId: string
  ): Promise<JobLifecycleEvent[]> {
    const events: JobLifecycleEvent[] = [];
    const timestamp = new Date().toISOString();

    // Job start detection
    if (telemetryData.printer_state === 'Printing' && telemetryData.print_progress === 0) {
      events.push({
        userId,
        machineId,
        activityType: 'job_start',
        timestamp,
        details: {
          filename: telemetryData.filename,
          estimated_time: telemetryData.estimated_print_time
        }
      });
    }

    // Job completion detection
    if (telemetryData.printer_state === 'Operational' && telemetryData.print_progress === 100) {
      const quality = this.calculateJobQuality(telemetryData);
      events.push({
        userId,
        machineId,
        activityType: 'job_completion_success',
        timestamp,
        details: {
          filename: telemetryData.filename,
          duration: telemetryData.print_time,
          quality
        }
      });
    }

    // Performance summary (if printing for extended periods)
    if (telemetryData.printer_state === 'Printing' && telemetryData.print_progress > 50) {
      events.push({
        userId,
        machineId,
        activityType: 'performance_summary',
        timestamp,
        details: {
          progress: telemetryData.print_progress,
          temps: {
            hotend: telemetryData.hotend_temp,
            bed: telemetryData.bed_temp
          }
        }
      });
    }

    return events;
  }

  /**
   * Calculate job quality based on telemetry
   */
  private calculateJobQuality(telemetryData: any): string {
    // Simple quality assessment based on temperature stability
    const hotendTemp = telemetryData.hotend_temp || 0;
    const bedTemp = telemetryData.bed_temp || 0;
    
    if (hotendTemp > 190 && bedTemp > 50) {
      return 'PERFECT';
    } else if (hotendTemp > 160 && bedTemp > 30) {
      return 'GOOD';
    } else {
      return 'POOR';
    }
  }

  /**
   * Write job events to blockchain
   */
  private async writeJobEventToBlockchain(event: JobLifecycleEvent): Promise<void> {
    try {
      // Skip blockchain recording for now (method not implemented)
      console.log('Blockchain recording disabled temporarily');
    } catch (error) {
      console.error('Error writing to blockchain:', error);
    }
  }

  /**
   * Award MINT to user with validation
   */
  private async awardMintToUser(
    userId: string, 
    mintAmount: number, 
    activityType: string
  ): Promise<void> {
    try {
      // Use the database function to award MINT tokens
      const { error } = await supabase.rpc('award_mint_tokens', {
        p_user_id: userId,
        p_mint_amount: mintAmount,
        p_activity_type: activityType
      });
      
      if (error) {
        console.error('Failed to award MINT:', error);
        return;
      }

      console.log(`Awarded ${mintAmount} MINT to user ${userId} for ${activityType}`);

    } catch (error) {
      console.error('Error awarding MINT to user:', error);
    }
  }

  /**
   * Get user MINT summary
   */
  async getUserMintSummary(userId: string): Promise<any> {
    const { data, error } = await supabase
      .from('user_points_summary')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (error) {
      console.error('Error fetching user MINT summary:', error);
      return null;
    }

    return data;
  }

  /**
   * Sync offline data when connection is restored
   */
  async syncOfflineData(machineId: string, offlineData: any[]): Promise<void> {
    console.log('Syncing offline data for machine:', machineId);

    for (const dataPoint of offlineData) {
      try {
        // Store offline telemetry data
        await supabase.from('telemetry_data').insert({
          machine_id: machineId,
          data: dataPoint.telemetry,
          timestamp: dataPoint.timestamp,
          sync_status: 'offline_sync',
          offline_duration: dataPoint.offline_duration || 0
        });

        // Process for job events
        const { data: machine } = await supabase
          .from('machines')
          .select('user_id')
          .eq('id', machineId)
          .single();

        if (machine) {
          await this.processTelemetryData(machineId, dataPoint.telemetry, machine.user_id);
        }

      } catch (error) {
        console.error('Error syncing offline data point:', error);
      }
    }
  }

  /**
   * Generate validation hash for MINT rewards
   */
  generateValidationHash(
    userId: string, 
    machineId: string, 
    mintAmount: number, 
    timestamp: string
  ): string {
    // Simple hash generation for validation
    const data = `${userId}-${machineId}-${mintAmount}-${timestamp}`;
    return Buffer.from(data).toString('base64');
  }

  /**
   * Validate job duration for reasonableness
   */
  private validateJobDuration(duration: number): boolean {
    // Job should be between 1 minute and 24 hours
    return duration > 60 && duration < 86400;
  }

  /**
   * Calculate efficiency score for jobs
   */
  private calculateEfficiencyScore(telemetryData: any): number {
    const baseScore = 100;
    
    // Deduct points for temperature variations
    const tempVariation = Math.abs((telemetryData.hotend_temp || 200) - 200);
    const tempPenalty = Math.min(tempVariation * 0.5, 20);
    
    return Math.max(0, baseScore - tempPenalty);
  }
}
