// main.ts — Deno Edge Function with TBIP dynamic scaling + Autonomic Minting
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import nacl from "https://esm.sh/tweetnacl@1.0.3";
import bs58 from "https://esm.sh/bs58@4.0.1";
import { Connection, Keypair, PublicKey, sendAndConfirmTransaction, Transaction } from "https://esm.sh/@solana/web3.js@1.95.2";
import { getOrCreateAssociatedTokenAccount, createTransferCheckedInstruction } from "https://esm.sh/@solana/spl-token@0.4.8";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

serve((req) => router(req));

/* ---------- Router ---------- */
async function router(req: Request): Promise<Response> {
  if (req.method === "OPTIONS")
    return new Response(null, { headers: corsHeaders });

  const url = new URL(req.url);
  try {
    if (req.method === "POST" && url.pathname.endsWith("/register-machine")) {
      return await handleRegisterMachine(req);
    }
    if (req.method === "POST" && url.pathname.endsWith("/submit-job")) {
      return await handleSubmitJob(req);
    }
    if (req.method === "POST" && url.pathname.endsWith("/complete-job")) {
      return await handleCompleteJob(req);
    }
    if (req.method === "POST" && url.pathname.endsWith("/autonomic-minting-check")) {
      return await handleAutonomicMintingCheck(req);
    }
    if (req.method === "GET" && url.pathname.endsWith("/metrics")) {
      return await handleGetMetrics(req);
    }
    return new Response("Not Found", { status: 404, headers: corsHeaders });
  } catch (err) {
    console.error("Edge function error:", err);
    return new Response(
      JSON.stringify({ error: String(err?.message ?? err) }),
      {
        status: 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
  }
}

/* ---------- Supabase / Helpers ---------- */
function getSupabaseClient() {
  const url = Deno.env.get("SUPABASE_URL") ?? "";
  const key = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";
  return createClient(url, key);
}

async function sendCriticalAlert(message: string, metadata: Record<string, any> = {}) {
  try {
    await fetch("https://lsijwmklicmqtuqxhgnu.supabase.co/functions/v1/alert-ts", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ severity: "critical", message, metadata }),
    });
  } catch (err) {
    console.error("Failed to send alert:", err);
  }
}

function parseJsonBody(req: Request) {
  return req.json();
}

function makeConnection() {
  const rpc = Deno.env.get("HELIUS_RPC_URL") || "https://mainnet.helius-rpc.com/?api-key=2c13462d-4a64-4c5b-b410-1520219d73aa";
  return new Connection(rpc, "confirmed");
}

function loadTreasuryKeypair() {
  const secret = Deno.env.get("HOT_WALLET");
  if (!secret) throw new Error("HOT_WALLET secret not set");
  const arr = JSON.parse(secret);
  return Keypair.fromSecretKey(new Uint8Array(arr));
}

function mintDecimals() {
  return Number(Deno.env.get("MINT_DECIMALS") ?? "6");
}

function envNumber(name: string, fallback: number): number {
  const v = Deno.env.get(name);
  return v ? Number(v) : fallback;
}

/* ---------- Configuration ---------- */
const CONFIG = {
  REWARD_RATE_PER_SECOND: envNumber("REWARD_RATE_PER_SECOND", 0.005),
  MIN_REWARD_PER_JOB: envNumber("MIN_REWARD_PER_JOB", 0.5),
  MAX_REWARD_PER_JOB: envNumber("MAX_REWARD_PER_JOB", 10),
  MIN_SECONDS_FOR_REWARD: envNumber("MIN_SECONDS_FOR_REWARD", 60),
  MIN_LINEAR_SECONDS: envNumber("MIN_LINEAR_SECONDS", 600),
  TAPER_START_SECONDS: envNumber("TAPER_START_SECONDS", 3600),
  DAILY_LIMIT_PER_MACHINE: envNumber("DAILY_LIMIT_PER_MACHINE", 400),
  TIER_MULTIPLIERS_RAW: Deno.env.get("TIER_MULTIPLIERS") ?? '{"robot":1.5,"printer":1.2,"cnc":1.8,"agent":1.0,"default":1.0}',
  DYNAMIC_SCALE_SECONDS: envNumber("DYNAMIC_SCALE_SECONDS", 100000),
  MINT_RUNWAY_DAYS_TARGET: envNumber("MINT_RUNWAY_DAYS_TARGET", 7),
  MINT_MAX_PERCENT_PER_EVENT: envNumber("MINT_MAX_PERCENT_PER_EVENT", 1),
  TOTAL_SUPPLY_MINT: envNumber("TOTAL_SUPPLY_MINT", 85_000_000),
};

let TIER_MULTIPLIERS: Record<string, number> = {};
try {
  TIER_MULTIPLIERS = JSON.parse(CONFIG.TIER_MULTIPLIERS_RAW);
} catch (e) {
  console.warn("Invalid TIER_MULTIPLIERS JSON, using defaults.");
  TIER_MULTIPLIERS = {
    robot: 1.5,
    printer: 1.2,
    cnc: 1.8,
    agent: 1.0,
    default: 1.0,
  };
}

/* ---------- Reward Calculation ---------- */
function calculateReward(durationSeconds: number, machineMeta: Record<string, any>): number {
  const { REWARD_RATE_PER_SECOND, MIN_REWARD_PER_JOB, MAX_REWARD_PER_JOB, MIN_LINEAR_SECONDS, TAPER_START_SECONDS } = CONFIG;
  const machineClass = machineMeta?.class ?? machineMeta?.type ?? "default";
  const multiplier = TIER_MULTIPLIERS[machineClass] ?? 1.0;

  let reward = 0;
  if (durationSeconds < MIN_LINEAR_SECONDS) {
    reward = MIN_REWARD_PER_JOB;
  } else if (durationSeconds < TAPER_START_SECONDS) {
    reward = durationSeconds * REWARD_RATE_PER_SECOND;
  } else {
    reward = TAPER_START_SECONDS * REWARD_RATE_PER_SECOND * Math.sqrt(durationSeconds / TAPER_START_SECONDS);
  }

  reward *= multiplier;
  reward = Math.max(reward, MIN_REWARD_PER_JOB);
  reward = Math.min(reward, MAX_REWARD_PER_JOB);
  return Math.round(reward * 1e6) / 1e6;
}

function dailyLimitPerMachine(): number {
  return CONFIG.DAILY_LIMIT_PER_MACHINE;
}

/* ---------- Activity Ratio & Dynamic Scaling ---------- */
async function getNetworkSnapshot(supabase: any) {
  try {
    const since = new Date(Date.now() - 24 * 3600 * 1000).toISOString();
    const { data, error } = await supabase
      .from("jobs")
      .select("duration_seconds, machine_uuid")
      .gte("completed_at", since)
      .eq("status", "completed");

    if (error) throw error;

    const totalRuntime = (data ?? []).reduce((sum: number, j: any) => sum + Number(j.duration_seconds || 0), 0);
    const activeNodes = new Set((data ?? []).map((j: any) => j.machine_uuid)).size;

    const { data: snapshot } = await supabase
      .from("metrics_snapshot")
      .select("*")
      .eq("id", 1)
      .single()
      .catch(() => ({ data: null }));

    const prevTotal = Number(snapshot?.total_runtime_seconds || 0);
    const prevJobs = Number(snapshot?.total_jobs_completed || 0);

    const newTotals = {
      total_runtime_seconds: prevTotal + totalRuntime,
      total_jobs_completed: prevJobs + (data?.length || 0),
      active_nodes: activeNodes,
      updated_at: new Date().toISOString(),
    };

    await supabase.from("metrics_snapshot").upsert(
      { id: 1, ...newTotals },
      { onConflict: ["id"] }
    );

    return {
      totalRuntime: newTotals.total_runtime_seconds,
      activeNodes,
      jobsCompleted: newTotals.total_jobs_completed,
    };
  } catch (err) {
    console.error("getNetworkSnapshot failed:", err);
    return { totalRuntime: 0, activeNodes: 0, jobsCompleted: 0 };
  }
}

function calculateActivityRatio(snapshot: any): number {
  if (snapshot.activeNodes === 0) return 1.0;
  const baselineRuntime = 3600; // 1 hour baseline per node
  const ratio = snapshot.totalRuntime / (snapshot.activeNodes * baselineRuntime);
  return Math.max(0.5, Math.min(2.0, ratio));
}

function calculateActivityMultiplier(activityRatio: number): number {
  // activity_ratio^(-0.4) — asymptotic self-correction
  const bounded = Math.max(0.5, Math.min(2.0, activityRatio));
  return Math.pow(bounded, -0.4);
}

function calculateDynamicReward(
  durationSeconds: number,
  machineMeta: Record<string, any>,
  snapshot: any
): { reward: number; dynamicFactor: number; activityRatio: number } {
  const baseReward = calculateReward(durationSeconds, machineMeta);
  const activityRatio = calculateActivityRatio(snapshot);
  const activityMultiplier = calculateActivityMultiplier(activityRatio);

  const adjusted = baseReward * activityMultiplier;
  const rounded = Math.round(adjusted * 1e6) / 1e6;
  const final = Math.max(CONFIG.MIN_REWARD_PER_JOB, Math.min(rounded, CONFIG.MAX_REWARD_PER_JOB));

  return {
    reward: final,
    dynamicFactor: activityMultiplier,
    activityRatio,
  };
}

/* ---------- Autonomic Minting ---------- */
async function calculate24hBurnRate(supabase: any): Promise<number> {
  try {
    const since = new Date(Date.now() - 24 * 3600 * 1000).toISOString();
    const { data } = await supabase
      .from("payouts")
      .select("amount")
      .gte("created_at", since);

    const total24h = (data ?? []).reduce((sum: number, p: any) => sum + Number(p.amount || 0), 0);
    return total24h / 24; // MINT per hour
  } catch (err) {
    console.error("calculate24hBurnRate failed:", err);
    return 0;
  }
}

async function getTreasuryBalance(
  connection: any,
  treasuryKeypair: Keypair,
  mintAddress: string
): Promise<number> {
  try {
    const mintPub = new PublicKey(mintAddress);
    const ata = await getOrCreateAssociatedTokenAccount(connection, treasuryKeypair, mintPub, treasuryKeypair.publicKey);
    const balance = await connection.getTokenAccountBalance(ata.address);
    return balance.value.uiAmount ?? 0;
  } catch (err) {
    console.error("getTreasuryBalance failed:", err);
    return 0;
  }
}

function calculateMintAmount(
  activityRatio: number,
  burnRatePerHour: number,
  targetRunwayDays: number
): number {
  const targetRunway = burnRatePerHour * 24 * targetRunwayDays;
  const bounded = Math.max(0.5, Math.min(2.0, activityRatio));
  const activityMultiplier = Math.pow(bounded, -0.4);
  const amountToMint = targetRunway * activityMultiplier;
  const maxPerEvent = CONFIG.TOTAL_SUPPLY_MINT * (CONFIG.MINT_MAX_PERCENT_PER_EVENT / 100);
  return Math.min(amountToMint, maxPerEvent);
}

async function handleAutonomicMintingCheck(req: Request): Promise<Response> {
  const supabase = getSupabaseClient();
  try {
    const mintAddress = Deno.env.get("MINT_ADDRESS");
    if (!mintAddress) throw new Error("MINT_ADDRESS not set");

    const connection = makeConnection();
    const treasury = loadTreasuryKeypair();

    const snapshot = await getNetworkSnapshot(supabase);
    const burnRate = await calculate24hBurnRate(supabase);
    const currentBalance = await getTreasuryBalance(connection, treasury, mintAddress);

    const activityRatio = calculateActivityRatio(snapshot);
    const runwayDays = burnRate > 0 ? currentBalance / (burnRate * 24) : 9999;

    console.log(
      `[MINTING CHECK] Balance: ${currentBalance.toFixed(2)} MINT, Runway: ${runwayDays.toFixed(1)} days, Activity: ${activityRatio.toFixed(2)}x`
    );

    if (runwayDays < CONFIG.MINT_RUNWAY_DAYS_TARGET && snapshot.activeNodes > 0) {
      const toMint = calculateMintAmount(activityRatio, burnRate, CONFIG.MINT_RUNWAY_DAYS_TARGET);
      console.log(`[MINTING] Triggered: ${toMint.toFixed(2)} MINT (activity: ${activityRatio.toFixed(2)}x)`);

      await supabase.from("minting_events").insert({
        amount: toMint,
        reason: `runway_${runwayDays.toFixed(1)}_days`,
        activity_ratio: activityRatio,
        burn_rate_per_hour: burnRate,
        treasury_balance_before: currentBalance,
        timestamp: new Date().toISOString(),
      });

      return jsonResponse(
        {
          success: true,
          minting_triggered: true,
          amount_to_mint: toMint,
          activity_ratio: activityRatio,
          runway_days: runwayDays,
        },
        200
      );
    }

    return jsonResponse(
      {
        success: true,
        minting_triggered: false,
        runway_days: runwayDays,
        threshold_days: CONFIG.MINT_RUNWAY_DAYS_TARGET,
        activity_ratio: activityRatio,
      },
      200
    );
  } catch (err: any) {
    console.error("autonomicMintingCheck failed:", err);
    await sendCriticalAlert(`Minting check failed: ${err.message}`);
    return jsonResponse({ error: err.message }, 500);
  }
}

/* ---------- Endpoint Handlers ---------- */
async function handleRegisterMachine(req: Request): Promise<Response> {
  const supabase = getSupabaseClient();
  const body = await parseJsonBody(req);
  let { machine_uuid, machine_pubkey_base58, owner_user_id, metadata } = body;

  if (!machine_pubkey_base58) {
    return jsonResponse({ error: "machine_pubkey_base58 required" }, 400);
  }

  if (!machine_uuid) {
    machine_uuid = crypto.randomUUID();
  }

  try {
    const pubBytes = bs58.decode(machine_pubkey_base58);
    if (!(pubBytes instanceof Uint8Array) || pubBytes.length !== 32) {
      return jsonResponse({ error: "machine_pubkey_base58 must decode to 32 bytes" }, 400);
    }
  } catch (e) {
    return jsonResponse({ error: "machine_pubkey_base58 invalid base58" }, 400);
  }

  const { error } = await supabase.from("machines").upsert(
    {
      machine_uuid,
      machine_pubkey: machine_pubkey_base58,
      owner_user_id: owner_user_id ?? null,
      metadata: metadata ?? null,
      registered_at: new Date().toISOString(),
    },
    { onConflict: ["machine_uuid"] }
  );

  if (error) {
    return jsonResponse({ error: error.message }, 500);
  }

  return jsonResponse({ success: true, machine_uuid }, 200);
}

async function handleSubmitJob(req: Request): Promise<Response> {
  const supabase = getSupabaseClient();
  const body = await parseJsonBody(req);
  const { machine_uuid, job_hash, complexity, payload } = body;

  if (!machine_uuid || !job_hash) {
    return jsonResponse({ error: "machine_uuid and job_hash required" }, 400);
  }

  if (typeof complexity !== "number" || complexity < 0.5 || complexity > 2.0) {
    return jsonResponse({ error: "complexity must be 0.5-2.0" }, 400);
  }

  const { data: existing } = await supabase
    .from("jobs")
    .select("job_hash, status")
    .eq("job_hash", job_hash)
    .single()
    .catch(() => ({ data: null }));

  if (existing) {
    return jsonResponse(
      {
        success: false,
        error: "job_hash already exists",
        status: existing.status,
      },
      409
    );
  }

  const { error } = await supabase.from("jobs").insert({
    job_hash,
    machine_uuid,
    complexity_claimed: complexity,
    job_payload: payload ?? null,
    status: "started",
    started_at: new Date().toISOString(),
  });

  if (error) {
    return jsonResponse({ error: error.message }, 500);
  }

  return jsonResponse({ success: true, job_hash }, 200);
}

async function handleCompleteJob(req: Request): Promise<Response> {
  const supabase = getSupabaseClient();
  const body = await parseJsonBody(req);
  const { machine_uuid, job_hash, recipient_wallet, completion_proof } = body;

  if (!machine_uuid || !job_hash || !recipient_wallet || !completion_proof) {
    return jsonResponse(
      { error: "machine_uuid, job_hash, recipient_wallet, completion_proof required" },
      400
    );
  }

  const { data: jobRow } = await supabase
    .from("jobs")
    .select("*")
    .eq("job_hash", job_hash)
    .single()
    .catch(() => ({ data: null }));

  if (!jobRow) {
    return jsonResponse({ error: "job not found; submit first" }, 404);
  }

  if (jobRow.status === "completed") {
    return jsonResponse({ success: true, tx_signature: jobRow.tx_signature }, 200);
  }

  const { data: machine } = await supabase
    .from("machines")
    .select("*")
    .eq("machine_uuid", machine_uuid)
    .single()
    .catch(() => ({ data: null }));

  if (!machine) {
    return jsonResponse({ error: "machine not registered" }, 404);
  }

  // Verify signature
  const { timestamp, signature_base58 } = completion_proof;
  if (!timestamp || !signature_base58) {
    return jsonResponse({ error: "completion_proof missing fields" }, 400);
  }

  const message = `${job_hash}|${recipient_wallet}|${timestamp}`;
  const messageBytes = new TextEncoder().encode(message);

  try {
    const signatureBytes = bs58.decode(signature_base58);
    const pubkeyBytes = bs58.decode(machine.machine_pubkey);
    const ok = nacl.sign.detached.verify(messageBytes, signatureBytes, pubkeyBytes);

    if (!ok) {
      await sendCriticalAlert(`Signature verification failed for machine ${machine_uuid}`, {
        machine_uuid,
        job_hash,
      });
      await supabase
        .from("jobs")
        .update({
          status: "failed",
          error_message: "signature verification failed",
        })
        .eq("job_hash", job_hash);
      return jsonResponse({ error: "signature verification failed" }, 401);
    }
  } catch (e) {
    await sendCriticalAlert(`Base58 decode failed for job ${job_hash}`, {
      machine_uuid,
      job_hash,
    });
    return jsonResponse({ error: "Invalid base58 in signature or pubkey" }, 400);
  }

  // Duration checks
  const startedAt = new Date(jobRow.started_at).getTime();
  const completedAt = new Date(timestamp).getTime();
  const durationSeconds = Math.floor((completedAt - startedAt) / 1000);

  if (durationSeconds < CONFIG.MIN_SECONDS_FOR_REWARD) {
    await supabase
      .from("jobs")
      .update({
        status: "failed",
        error_message: "job duration too short",
      })
      .eq("job_hash", job_hash);
    await sendCriticalAlert(`Suspicious job: ${durationSeconds}s for machine ${machine_uuid}`, {
      machine_uuid,
      job_hash,
    });
    return jsonResponse({ error: "Job duration too short for valid work" }, 400);
  }

  if (durationSeconds > 7 * 24 * 3600) {
    return jsonResponse({ error: "Job duration exceeds maximum (7 days)" }, 400);
  }

  await supabase
    .from("jobs")
    .update({ duration_seconds: durationSeconds })
    .eq("job_hash", job_hash);

  // Calculate dynamic reward with activity ratio
  const snapshot = await getNetworkSnapshot(supabase);
  const machineMeta = machine.metadata ?? {};
  const { reward: rewardMint, dynamicFactor, activityRatio } = calculateDynamicReward(
    durationSeconds,
    machineMeta,
    snapshot
  );

  const decimals = mintDecimals();
  const rewardBaseUnits = BigInt(Math.floor(rewardMint * Math.pow(10, decimals)));

  // Daily limit check
  const since = new Date(Date.now() - 24 * 3600 * 1000).toISOString();
  const { data: recentPayouts } = await supabase
    .from("payouts")
    .select("amount")
    .eq("machine_uuid", machine_uuid)
    .gte("created_at", since);

  const totalLast24 = (recentPayouts ?? []).reduce((sum: number, r: any) => sum + Number(r.amount || 0), 0);
  if (totalLast24 + rewardMint > dailyLimitPerMachine()) {
    return jsonResponse({ error: "daily limit exceeded" }, 429);
  }

  // Lock job
  await supabase
    .from("jobs")
    .update({
      status: "processing",
      processing_at: new Date().toISOString(),
    })
    .eq("job_hash", job_hash)
    .eq("status", "started");

  try {
    const connection = makeConnection();
    const treasury = loadTreasuryKeypair();
    const mintAddress = Deno.env.get("MINT_ADDRESS");
    if (!mintAddress) throw new Error("MINT_ADDRESS not set");

    const mintPub = new PublicKey(mintAddress);
    const senderAta = await getOrCreateAssociatedTokenAccount(
      connection,
      treasury,
      mintPub,
      treasury.publicKey
    );

    const balance = await connection.getTokenAccountBalance(senderAta.address);
    const currentBalance = balance.value.uiAmount ?? 0;

    if (currentBalance < rewardMint) {
      await sendCriticalAlert(`Treasury depleted: ${currentBalance} MINT`, {
        required: rewardMint,
      });
      await supabase
        .from("jobs")
        .update({
          status: "failed",
          error_message: "Treasury depleted",
        })
        .eq("job_hash", job_hash);
      return jsonResponse({ error: "Treasury depleted" }, 503);
    }

    const solBalance = await connection.getBalance(treasury.publicKey);
    if (solBalance / 1e9 < 0.01) {
      await sendCriticalAlert(`SOL balance critically low: ${solBalance / 1e9} SOL`);
      await supabase
        .from("jobs")
        .update({
          status: "failed",
          error_message: "Insufficient SOL",
        })
        .eq("job_hash", job_hash);
      return jsonResponse({ error: "Insufficient SOL for fees" }, 503);
    }

    const recipientPubKey = new PublicKey(recipient_wallet);
    const recipientAta = await getOrCreateAssociatedTokenAccount(
      connection,
      treasury,
      mintPub,
      recipientPubKey
    );

    const transferIx = createTransferCheckedInstruction(
      senderAta.address,
      mintPub,
      recipientAta.address,
      treasury.publicKey,
      rewardBaseUnits,
      decimals
    );

    const tx = new Transaction().add(transferIx);
    const txSig = await sendAndConfirmTransaction(connection, tx, [treasury], {
      skipPreflight: false,
      commitment: "confirmed",
    });

    await supabase.from("payouts").insert({
      job_hash,
      machine_uuid,
      recipient: recipient_wallet,
      amount: rewardMint,
      amount_base_units: rewardBaseUnits.toString(),
      mint_address: mintAddress,
      tx_signature: txSig,
      activity_ratio: activityRatio,
      created_at: new Date().toISOString(),
    });

    await supabase
      .from("jobs")
      .update({
        status: "completed",
        completed_at: new Date().toISOString(),
        completion_proof,
        reward_amount_numeric: rewardMint,
        tx_signature: txSig,
        recipient_wallet,
        dynamic_factor: dynamicFactor,
        activity_ratio: activityRatio,
      })
      .eq("job_hash", job_hash);

    const solscan = `https://solscan.io/tx/${txSig}?cluster=mainnet`;
    return jsonResponse(
      {
        success: true,
        tx_signature: txSig,
        reward: rewardMint,
        activity_ratio: activityRatio,
        dynamic_factor: dynamicFactor,
        solscan,
      },
      200
    );
  } catch (err: any) {
    console.error("Transaction failed:", err);
    await sendCriticalAlert(`Transaction failed: ${err.message}`, {
      machine_uuid,
      job_hash,
      error: err.message,
    });
    await supabase
      .from("jobs")
      .update({
        status: "failed",
        error_message: `Transaction failed: ${err.message}`,
      })
      .eq("job_hash", job_hash);
    return jsonResponse({ error: `Transaction failed: ${err.message}` }, 500);
  }
}

async function handleGetMetrics(req: Request): Promise<Response> {
  const supabase = getSupabaseClient();
  try {
    const snapshot = await getNetworkSnapshot(supabase);
    const activityRatio = calculateActivityRatio(snapshot);
    const activityMultiplier = calculateActivityMultiplier(activityRatio);
    const burnRate = await calculate24hBurnRate(supabase);

    const connection = makeConnection();
    const treasury = loadTreasuryKeypair();
    const mintAddress = Deno.env.get("MINT_ADDRESS") ?? "";
    const currentBalance = mintAddress ? await getTreasuryBalance(connection, treasury, mintAddress) : 0;

    const { data: recentJobs } = await supabase
      .from("jobs")
      .select("*")
      .eq("status", "completed")
      .order("completed_at", { ascending: false })
      .limit(10);

    const { data: mintingEvents } = await supabase
      .from("minting_events")
      .select("*")
      .order("timestamp", { ascending: false })
      .limit(5);

    return jsonResponse(
      {
        network: {
          active_nodes: snapshot.activeNodes,
          total_runtime_seconds: snapshot.totalRuntime,
          total_jobs_completed: snapshot.jobsCompleted,
        },
        activity: {
          activity_ratio: activityRatio,
          activity_multiplier: activityMultiplier,
          burn_rate_per_hour: burnRate,
        },
        treasury: {
          balance_mint: currentBalance,
          runway_days: burnRate > 0 ? currentBalance / (burnRate * 24) : 9999,
        },
        recent_jobs: recentJobs ?? [],
        recent_minting_events: mintingEvents ?? [],
      },
      200
    );
  } catch (err: any) {
    console.error("getMetrics failed:", err);
    return jsonResponse({ error: err.message }, 500);
  }
}

/* ---------- Utility ---------- */
function jsonResponse(obj: any, status: number = 200): Response {
  return new Response(JSON.stringify(obj), {
    status,
    headers: { ...corsHeaders, "Content-Type": "application/json" },
  });
}
